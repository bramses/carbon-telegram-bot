import carbon from '../../util/carbon'
import entity from '../../util/entity'
import { ContextMessageUpdate } from 'telegraf'
import { getKeyboard } from '../../util/keyboard'
import fetch from 'node-fetch'
import { config } from '../../app.config'



/*
This code is creating a function that returns an async function.
- generated by stenography 🤖
*/
export function factory() {
  /*
  This code is creating an asynchronous function that will be called when the user presses a writng gnfify.
  - generated by stenography 🤖
  */
  return async function handler(ctx: ContextMessageUpdate) {

    if (!ctx.message) return
    if (!ctx.chat) return

    const deleteOriginalMessage = await ctx.config.get('deleteOriginalMessage')

    const message = ctx.message.reply_to_message || ctx.message

    const sentMessage = await ctx.reply('Processing...', {
      reply_to_message_id: ctx.message.message_id
    })

    let fetchUrl = 'https://stenography-worker.bramses.workers.dev/';


    let steno = ""

    let options = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ "context": "telegram", "code": message.text, "api_key": config.stenography.token, "audience": "all" })
    };

    /*
    This code is fetching the JSON response from a URL.
    - generated by stenography 🤖
    */
    const resp = await fetch(fetchUrl, options)
    const json = await resp.json()

    /*
    This code checks if the value of json.dev is "dev" and then prints out a line with STENOGRAPHY:DEV followed by whatever value is in json.dev
    - generated by stenography 🤖
    */
    if ("dev" in json) {
      steno += `\n\nSTENOGRAPHY:DEV\n\n${json.dev}`
    }

    if ("pm" in json) {
      steno += `\n\nSTENOGRAPHY:PM${json.pm}`
    }

    let stenoComment = `/*${steno}\n\n*/\n\n`
    message.text = stenoComment + message.text
    if (message.entities) message.entities[0].length = message.text.length

    const {
      chat: { id: chatId }
    } = ctx
    const messageId = message.message_id

    console.log(message)

    const url = entity.toUrl(message, await ctx.config.getAll())

    if (!url) return

    const imageBuffer = await carbon.getScreenshotFromUrl({ url })

    const extra = getKeyboard(url).asExtra().inReplyTo(ctx.message.message_id)

    const { message_id: imageMessageId } = await ctx.telegram.sendPhoto(
      chatId,
      { source: imageBuffer },
      extra as any
    )
    await ctx.telegram.deleteMessage(chatId, sentMessage.message_id)

    const refreshData = { from: messageId, to: imageMessageId, hideRefresh: deleteOriginalMessage }

    const secondKeyboard = getKeyboard(url, refreshData).asString()

    await ctx.telegram.editMessageReplyMarkup(chatId, imageMessageId, undefined, secondKeyboard)

    if (deleteOriginalMessage) {
      await ctx.telegram.deleteMessage(ctx.chat.id, ctx.message.message_id).catch(() => { })
    }
  }
}

export default { factory }
